git log - история изменений, коммиты которые есть в истории
    git log -p - коммиты с более подробным выводом
git status - состояние
git show - показывает объект в подробностях
    git show <commit hach> - подробности о коммите
git restore <fileName> - откатывает изменения в файле на состояние последнего коммита
git diff - показывает какие изменения были внесены в файл с момента последнего коммита
    git diff --staged - изменения которые уже находятся в index
git commit -am "" - a означает взять все файлы которые были изменены и добавить их в index
git mv - перемеиновать/переместить: <oldName> <newName> or <fileName (oldName)> </path/newName>
git rm - удалить <fileName> 


.gitignore
### or # text - комментарий
__pycache__/ - игнор целой папки pycache
* .py[cod] - игнор файлов с любым именем с расширением .py .pc .po .pd
logs - целая папка 
text.txt - только файл
res/prod.json - файл prod внутри res


37:00 
в master(main) всегда находится стабильный код !!!
все другие разработки ведутся в других ветках
git branch new-api - новая ветка
    -a - показать все ветки 
    -d bugfix - удаление ветки bugfix
git checkout new-api - переключение на новую ветку
    <hash summa> - перемещение указателя head на указанный коммит, 
    состояние файло будет точно следовать этому коммиту,
    мы ни как не трогаем указатели веток
    detached at указатель head не указывает ни на одну из веток
git checkout -b new-branch <hash> - новая ветка от другого коммита
git checkout <fileName> - состояние файла вернется на состояние
    последнего коммита (отмена правок),
    не меняем указатели веток

git merge - слияние веток
Fast-forward - просто передвежение указателя (прямая линия, прямой родитель)
merge commit - коммит который указывает на два пред коммита

git reset - более опасная 
    --hard <hash> - всен правки проигнорируются и указатель тек. ветки будет смещен
    на коммит хэш сумму которой указали

git fetch origin - обновление ветки слежения

git rebase - перебазирование

-----------------------------

git pull origin main